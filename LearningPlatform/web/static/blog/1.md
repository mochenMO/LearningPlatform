# 图像的任意大小的缩放
### 最近邻插值法(不推荐使用)
![在这里插入图片描述](https://img-blog.csdnimg.cn/f8fe58100a514767adc9d863ef969310.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aKo5bCYX01P,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

算法核心：1. 通过新图的坐标计算**原图的坐标**,逆向映射。
2. 通过原图的坐标计算与该点最邻近的点坐标，原图坐标（0.3,0.3）与它最
邻近的点的坐标为（0,0），即新图坐标中该点的RGB等于原图（0,0）点的RGB。==即该点RGB等于最近点的RGB==

>**通过新图的坐标计算原图的坐标**
>$oldX=newX*\frac{oldW}{newW}$ &emsp;&emsp;&emsp;&emsp; $oldY=newY*\frac{oldH}{newH}$



```c
// 缩放图片(最近邻插值法)(部分区域有明显的锯齿状，不推荐使用)
IMAGE Transform_shape_nearest(IMAGE im, unsigned int newWidth, unsigned int newHeight)
{
    // 算法核心：通过新图的坐标计算原图的坐标

    float fx, fy;    // f->former  原来（原图坐标）
    float dx, dy;    // d->Decimal 小数（原图坐标的小数部分）

    BGRA* bgra = (BGRA*)malloc(sizeof(BGRA) * newWidth * newHeight);

    // 遍历整张新图
    for (unsigned int i = 0; i < newWidth * newHeight; i++)
    {
        // 通过新图的坐标计算原图的坐标
        fx = (i % newWidth) * ((float)im.w / newWidth);
        fy = (i / newWidth) * ((float)im.h / newHeight);

        // 计算原图坐标的小数部分
        dx = fx - (int)fx;
        dy = fy - (int)fy;

        fx = (dx <= 0.5 ? (int)fx : (int)fx + 1);
        fy = (dy <= 0.5 ? (int)fy : (int)fy + 1);
    
        unsigned int k = fx + fy * im.w; // 注意乘的是原图的w

        if (k >= im.w * im.h)  // 判断k是否越界
            k = im.w * im.h - 1;

        bgra[i].blue = im.color[k].blue;
        bgra[i].green = im.color[k].green;
        bgra[i].red = im.color[k].red;
        bgra[i].transparency = 255;
    }


    free(im.color);
    im.color = bgra;
    im.w = newWidth;
    im.h = newHeight;
    return im;
}
// 代码测试
/*
	IMAGE image1 = Image_load("123.bmp");	
	
	image1 = Transform_shape_nearest(image1, 1200, 600)
	
	Image_free(image1);
	Image_show("01.bmp");
*/
```


##  双线性插值法
![在这里插入图片描述](https://img-blog.csdnimg.cn/3a49751378f84174b14d4945dab80b65.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aKo5bCYX01P,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)
算法核心：1. 通过新图的坐标计算**原图的坐标**，,逆向映射。
2. 通过坐标值，按权重分配像素颜色值,==离谁近谁权重大==。
>**计算（0.4,0）**
>(0.4,0)blue = (0,0)blue $*$ (1-0.4) + (1,0)blue $*$ 0.4
>**计算（0.4,1）**
>(0.4,1)blue = (0,1)blue $*$ (1-0.4) + (1,1)blue $*$ 0.4 
>**计算（0.4,0.6）**
>(0.4,0.6)blue = (0.4,0)blue $*$ (1-0.6) + (0.4,1)blue $*$ 0.6

>**令四个角上的点的一维坐标为k1,k2,k3,k4。所求点的小数部分为dx,dy可得**
>$$color=\left(k_{1}\cdot\left(1-dx\right)+k_{2}\cdot dx\right)\cdot\left(1-dy\right)+\left(k_{3}\cdot\left(1-dx\right)+k_{4}\cdot dx\right)\cdot dy$$

```c
// 缩放图片(双线性插值法)(推荐使用)
IMAGE Transform_shape_linear(IMAGE im, unsigned int newWidth, unsigned int newHeight)
{
    float fx, fy, dx, dy;
    int k1, k2, k3, k4;

    BGRA* bgra = (BGRA*)malloc(sizeof(BGRA) * newWidth * newHeight);

    for (unsigned int i = 0; i < newWidth * newHeight; i++)
    {
        // 通过新图的坐标计算原图的坐标
        fx = (i % newWidth) * ((float)im.w / newWidth);
        fy = (i / newWidth) * ((float)im.h / newHeight);

        dx = fx - (int)fx;
        dy = fy - (int)fy;

        fx = (int)fx;
        fy = (int)fy;

        // 分别计算四个角上点的坐标
        k1 = fx + fy * im.w;
        k2 = fx + 1 + fy * im.w;
        k3 = fx + (fy + 1) * im.w;
        k4 = fx + 1 + (fy + 1) * im.w;

        // 判断是否越界
        if (k1 >= im.w * im.h)
            k1 = im.w * im.h - 1;
        if (k2 >= im.w * im.h)
            k2 = im.w * im.h - 1;
        if (k3 >= im.w * im.h)
            k3 = im.w * im.h - 1;
        if (k4 >= im.w * im.h)
            k4 = im.w * im.h - 1;

        bgra[i].blue = (im.color[k1].blue * (1 - dx) + im.color[k2].blue * dx) * (1 - dy) + (im.color[k3].blue * (1 - dx) + im.color[k4].blue * dx) * dy;
        bgra[i].green = (im.color[k1].green * (1 - dx) + im.color[k2].green * dx) * (1 - dy) + (im.color[k3].green * (1 - dx) + im.color[k4].green * dx) * dy;
        bgra[i].red = (im.color[k1].red * (1 - dx) + im.color[k2].red * dx) * (1 - dy) + (im.color[k3].red * (1 - dx) + im.color[k4].red * dx) * dy;
        bgra[i].transparency = 255;
    }

    free(im.color);
    im.color = bgra;
    im.w = (int)newWidth;
    im.h = (int)newHeight;
    return im;
}
```

![请添加图片描述](https://img-blog.csdnimg.cn/017692101a344dc9a5e967a001adac7a.PNG?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aKo5bCYX01P,size_20,color_FFFFFF,t_70,g_se,x_16)
**左：最近邻（有明显锯齿），右：双线性**
&emsp; 