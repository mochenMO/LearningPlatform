## 二值图
二值图是指由只由黑白两种颜色的像素组成的图片，二值图的质量会直接影响到提取到的图片特征的是否有效，而决定二值图的质量的核心就是==阈值的计算==，像素值大于等于阈值则取255，小于阈值则取0。
### 自定义阈值法
```c
// 二值图(自定义阈值法)
void Transform_color_BW_DIY(IMAGE im, unsigned char Threshold)
{
    unsigned char color = 0;
    for (unsigned int i = 0; i < im.w * im.h; i++)
    {
        // 先转换成灰度图
        color = (im.color[i].blue * 114 + im.color[i].green * 587 + im.color[i].red * 299) / 1000;
        if (color >= Threshold) // Threshold的值在不同的图片中是不同的
            color = 255;
        else
            color = 0;

        im.color[i].blue = color;
        im.color[i].green = color;
        im.color[i].red = color;
    }
}
```

### 最大类间方差法（大津法OTSU）
大津法OTSU是假设阈值将图像分成背景和前景两部分。计算背景和前景之间的类间方差，==类间方差越大==说明背景和前景之间的差别越大，二值图的效果越好。==大津法OSTU，适用双峰直方图。当图像的整体颜色差别不大时，不推荐使用。==
>**类间方差计算公式**
>$$g=\frac{w_{前}}{1-w_{前}}\cdot\left(u_{前}-u_{总}\right)^{2}$$
>**$w_{前}$：前景像素数的占比**
>**$u_{前}$：前景的平局灰度**
>**$u_{总}$：图像的平局灰度**
>**$g$：类间方差**

>**整理可得**
>$$g=\frac{\frac{n_{前}}{n_{总}}}{1-\frac{n_{前}}{n_{总}}}\cdot\left(\frac{\sum_{i=T}^{i=255}n_{i}\cdot i}{n_{总}}-\frac{\sum_{i=0}^{i=255}n_{i}\cdot i}{n_{总}}\right)^{2}$$
>**$n_{前}$：前景的像素数**
>**$n_{总}$：总的像素数**
>**$n_{i}$：对应像素颜色的像素数**

这里计算平局灰度，读者可能有点不理解，举个例子：一组7人每人10元，二组6人每人8元，三组11人每人5元，求计算平均每人几元。
>**解**
>$$\frac{7*10+6*8+11*5}{7+6+11}=7.2$$

```c
// 二值图(大津法OSTU，适用双峰直方图。当图像的整体颜色差别不大时，不推荐使用)
void Transform_color_BW_OSTU(IMAGE im)
{
    // 公式：g = w0 / (1 - w0) * (u0 - u)* (u0 - u) 当g最大时取到阈值T
    int colorMap[256] = { 0 };
    float w0 = 0; // 前景像素数的占比
    unsigned int u0 = 0; // 前景的平局灰度（灰度值*其对应的素数个数）的累加/前景的像素个数
    unsigned int u = 0;  // 图像的平局灰度（灰度值*其对应的素数个数）的累加/总的像素个数
    float g = 0;  // 方差
    unsigned char T = 0;    // 阈值

    // 创建灰度直方图
    for (unsigned int i = 0; i < im.w * im.h; i++)
        colorMap[im.color[i].blue] += 1;
  
    for (int i = 0; i < 256; i++)
         u += colorMap[i] * i;  // u暂时计算累加
    u /= (im.h * im.w);

    // 遍历 0-255 寻找合适的阈值 
    for(unsigned int m = 0 ; m < 256; m++)
    {
        for (int n = m; n < 256; n++)
        {
            w0 += colorMap[n]; // w0暂时计算，保存前景的所有像素个数
            u0 += colorMap[n] * n; // u0暂时计算累加
        }
        u0 /= w0;
        w0 /= (im.h * im.w);
        
        if((w0 / (1 - w0) * (u0 - u)* (u0 - u)) > g)
            g = w0 / (1 - w0) * (u0 - u)* (u0 - u), T = m;
    }
 Transform_color_BW_DIY(im, T);
}
```
![请添加图片描述](https://img-blog.csdnimg.cn/5e067bde626c4ecab6147aa0b5e79595.bmp?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aKo5bCYX01P,size_12,color_FFFFFF,t_70,g_se,x_16)
### 三角法TRIANGLE
![请添加图片描述](https://img-blog.csdnimg.cn/37268b07e1314195bb7c37604ca30a7c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aKo5bCYX01P,size_20,color_FFFFFF,t_70,g_se,x_16)

如图，在灰度直方图中，找到最低点和最高点，计算出这两点的函数（黄色直线），分别计算最低点和最高点之间的点到黄色直线的距离$d$，**当$d$取到最大时，取到$T$阈值**。==三角法TRIANGLE，适用单峰直方图。当图像的整体颜色差别不大时，不推荐使用==

>**计算公式**
>&emsp; &emsp; &emsp; &emsp; $d=\frac{\left|Ax_{0}+By_{0}+C\right|}{\sqrt{A^{2}+B^{2}}}$ &emsp;&emsp;  &emsp; &emsp;  $y=kx+b$
>**联立可得**
>$$d=\frac{\left|-kx_{0}+y_{0}-b\right|}{\sqrt{1+k^{2}}}$$

```c
// 二值图(三角法TRIANGLE，适用单峰直方图。当图像的整体颜色差别不大时，不推荐使用)
void Transform_color_BW_TRIANGLE(IMAGE im)
{
    int colorMap[256] = { 0 };
    unsigned char minColor = 0;
    unsigned int minCount = 0;
    unsigned char maxColor = 0;
    unsigned int maxCount = 0;
    int d = 0;  // 最短距离
    unsigned char T = 0; // 阈值

    // 创建灰度直方图
    for (unsigned int i = 0; i < im.w * im.h; i++)
        colorMap[im.color[i].blue] += 1;

    for (int i = 0; i < 256; i++)
    {
        if (im.color[i].blue < minColor)
            minColor = im.color[i].blue, minCount = colorMap[im.color[i].blue];
        if (im.color[i].blue > maxColor)
            maxColor = im.color[i].blue, maxCount = colorMap[im.color[i].blue];
    }

    float k = ((float)maxCount - minCount) / ((float)maxColor - minColor);
    float b = maxCount - k * maxColor;
   
    // 遍历寻找最近距离 
    for (unsigned int n = minColor; n <= maxColor; n++)
        if (abs((int)(-k * n + colorMap[n] - b)) / sqrt((double)(1 + k * k)) > b)
            b = abs((int)(-k * n + colorMap[n] - b)) / sqrt((double)(1 + k * k)), T = n;

    Transform_color_BW_DIY(im, T);
}
```
![请添加图片描述](https://img-blog.csdnimg.cn/9bf3a55837024614b7f69235b8e823ff.bmp?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aKo5bCYX01P,size_12,color_FFFFFF,t_70,g_se,x_16)
**识别出了部分云彩**
### 3.2.4 自适应阈值法
自适应阈值法是一种，类卷积的操作（卷积会在下文详细讲解），其核心是选取一定大小的区域(**区域的边长为奇数**)，用这区域的像素平均值来作为这一个区域的阈值。==自适应阈值法，当图片线条多且密时，不推荐使用==

```c
// 二值图(自适应阈值法，areaSize=25较合适，当图片线条多且密时，不推荐使用)
IMAGE Transform_color_BW_Adaptive(IMAGE im, int areaSize)
{
    // areaSize为区域的大小，区域越大，效果图的细节越好，areaSize=25较合适
    BGRA* bgra = (BGRA*)malloc(sizeof(BGRA) * im.w * im.h);
    int* p = (int*)malloc(sizeof(int) * areaSize); // p->position 位置坐标
    int k = (int)(sqrt((double)areaSize)) / 2;  // 重合区域边长的一半

    for (unsigned int i = 0; i < im.w * im.h; i++)
    {
        // 计算与卷积和对应重合区域的坐标
        int t = 0; // 记录p的下标
        for (int n = k; n >= -k; n--)
            for (int m = -k; m <= k; m++)
            {
                p[t] = ((i % im.w) + m) + (i / im.w + n) * im.w;
                t++;
            }

        // 判断是否越界
        for (int j = 0; j < areaSize; j++)
            if (p[j] < 0 || p[j] >= im.w * im.h)
                p[j] = i;

        unsigned int color = 0;
        for (int j = 0; j < areaSize; j++)
            color += im.color[p[j]].blue;
        color /= areaSize;

        if (im.color[i].blue >= color)
            bgra[i].blue = 255;
        else
            bgra[i].blue = 0;

        bgra[i].green = bgra[i].blue;
        bgra[i].red = bgra[i].blue;
    }

    free(p);
    free(im.color);
    im.color = bgra;
    return im;
}
```
**处理山**
![请添加图片描述](https://img-blog.csdnimg.cn/7e5c590e9c0e43628bd481f480666142.bmp?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aKo5bCYX01P,size_12,color_FFFFFF,t_70,g_se,x_16)
**处理人脸**
![请添加图片描述](https://img-blog.csdnimg.cn/abf264dcf6c040f0947f2ec575c0b37e.bmp)