## 图像的任意角度的旋转
![在这里插入图片描述](https://img-blog.csdnimg.cn/0b0fc1f49e1a4723a41c06ed3bd70b2c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aKo5bCYX01P,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)
1. 由矩阵旋转可得旋转后的坐标与旋转前坐标的转换
>$x''=x'\cos\theta+y'\sin\theta$ &emsp;&emsp;&emsp;&emsp;&emsp;$y''=y'\cos\theta-x'\sin\theta$

2. 由图可知，旋转后的图片离==第一象限==，$x$轴偏移了$bx$，$y$轴偏移了$by$，所以公式调整为
>$x''=x'\cos\theta+y'\sin\theta+bx$&emsp;&emsp;&emsp;&emsp;&emsp;$y''=y'\cos\theta-x'\sin\theta+by$
3. 实现的核心：==通过原图坐标计算新图坐标==，向前映射。
4. 注意旋转后的图片大小也会改变
5. 旋转后的图片会有许多空白区域，最后要对这些空白区域进行填充

```c
// 图像的任意角度的旋转
IMAGE Transform_shape_whirl(IMAGE im, float angle)
{
    // 转角度换成弧度
    angle = 3.141592 * angle / 180;

    float cosnum = (float)cos(angle);   
    float sinnum = (float)sin(angle);

    // 计算原图的四个角的坐标
    int fx1 = 0;
    int fy1 = 0;
    int fx2 = im.w - 1;
    int fy2 = 0;
    int fx3 = 0;
    int fy3 = im.h - 1;
    int fx4 = im.w - 1;
    int fy4 = im.h - 1;

    // 计算旋转后的图像四个角的坐标
    int nx1 = 0;
    int ny1 = 0;
    int nx2 = (int)(fx2 * cosnum + fy2 * sinnum);
    int ny2 = (int)(fy2 * cosnum - fx2 * sinnum);
    int nx3 = (int)(fx3 * cosnum + fy3 * sinnum);
    int ny3 = (int)(fy3 * cosnum - fx3 * sinnum);
    int nx4 = (int)(fx4 * cosnum + fy4 * sinnum);
    int ny4 = (int)(fy4 * cosnum - fx4 * sinnum);

    // 计算旋转后的图像的宽和高
    unsigned int width = abs(max(max(nx1, nx2), max(nx3, nx4))) + abs(min(min(nx1, nx2), min(nx3, nx4))) + 1;
    unsigned int hight = abs(max(max(ny1, ny2), max(ny3, ny4))) + abs(min(min(ny1, ny2), min(ny3, ny4))) + 1;

    // 计算旋转后的图像到第一象限的位置偏移
    int bx = abs(min(min(nx1, nx2), min(nx3, nx4)));
    int by = abs(min(min(ny2, ny3), ny4));

    // 申请并初始化内存空间
    BGRA* bgra = (BGRA*)calloc(width * hight, sizeof(BGRA));
    
    for (unsigned int i = 0; i < im.w * im.h; i++)
    {
        // 注意(int)放的位置，不能随便移动,因为y可能为负的小数 
        int k = ((i % im.w) * cosnum + (i / im.w) * sinnum + bx) + (int)((i / im.w) * cosnum - (i % im.w) * sinnum + by) * width;

        // 判断是否越界
        if (k >= width * hight)
            k = width * hight - 1;

        bgra[k].blue = im.color[i].blue;
        bgra[k].green = im.color[i].green;
        bgra[k].red = im.color[i].red;
        bgra[k].transparency = 255;
    }

    // 用邻近的像素填充空白区域
    for (unsigned int i = 0; i < width * hight; i++)
    {
        if (bgra[i].transparency != 255 && bgra[i + 1].transparency == 255)
        {
            bgra[i].blue = bgra[i - 1].blue;
            bgra[i].green = bgra[i - 1].green;
            bgra[i].red = bgra[i - 1].red;
            bgra[i].transparency = 255;
        }
    }

    free(im.color);
    im.color = bgra;
    im.w = width;
    im.h = hight;
    return im;
}
```
![请添加图片描述](https://img-blog.csdnimg.cn/009a56180c3248f5921e3f3d4d82cc20.bmp?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aKo5bCYX01P,size_11,color_FFFFFF,t_70,g_se,x_16)


## 图像的镜像翻转
图像的镜像翻转分为水平翻转和垂直翻转
**水平翻转是$y$坐标不变，$x$坐标翻转** 
**垂直翻转是$x$坐标不变，$y$坐标翻转**

```c
#define UPTURN_MODE_HORIZONTAL 0    // 水平翻转
#define UPTURN_MODE_VERTICAL 1      // 垂直翻转
// 图像的镜像翻转
IMAGE Transform_shape_upturn(IMAGE im, int upturn_mode)
{
    BGRA* bgra = (BGRA*)malloc(sizeof(BGRA) * im.w * im.h);

    if(upturn_mode == UPTURN_MODE_HORIZONTAL)
        for (unsigned int i = 0; i < im.w * im.h; i++)
            bgra[i] = im.color[(im.w - 1 - (i % im.w)) + i / im.w * im.w];  // 水平翻转是y坐标不变，x坐标翻转
    else if(upturn_mode == UPTURN_MODE_VERTICAL)
        for (unsigned int i = 0; i < im.w * im.h; i++)
            bgra[i] = im.color[(i % im.w) + (im.h - 1 - i / im.w ) * im.w]; // 垂直翻转是x坐标不变，y坐标翻转

    free(im.color);
    im.color = bgra;
    return im;
}
```
![请添加图片描述](https://img-blog.csdnimg.cn/5c4ffe6e5e6a4d3baaf3c109f4d5c6da.bmp?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aKo5bCYX01P,size_12,color_FFFFFF,t_70,g_se,x_16)

![请添加图片描述](https://img-blog.csdnimg.cn/a04b45174e324f25a40ebb5a7cdfa02a.bmp?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aKo5bCYX01P,size_12,color_FFFFFF,t_70,g_se,x_16)