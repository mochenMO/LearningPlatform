## 直方图均衡化
![在这里插入图片描述](https://img-blog.csdnimg.cn/4778f4eb97eb4c7f98b39e0a4221a9e0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aKo5bCYX01P,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

**1. 直方图均衡化：是一种==增强图像对比度==的方法，即让亮的地方更亮，暗的地方更暗，主要用于图像整体颜色偏淡，图像整体太亮，图像整体太暗，等图像整体变化度不够的情况。由图可知，其主要思想是将一副图像的颜色直方图分布变成近似均匀分布，从而增强图像的对比度。
2. 直方图均衡化核心公式**
>$$color=\frac{\left(RGB\max-RGB\min\right)}{N}\sum_{i=0}^{k}ni$$
>**$RGB\max$是：最大的RGB值一般为255**
>**$RGB\min$是：最小的RGB值一般为0**
>**N是：总的像素数一般为$w*h$**
>**$k$ 是：color的RGB值**
>**$\sum_{i=0}^{k}ni$ 是：所有小于color的RGB值的像素的个数之和**

**整理后的公式**
>$$color=\frac{255-0}{w\cdot h}\sum_{i=0}^{k}ni$$

**3.两种不同的直方图均衡化（实现代码差不多，但效果区别很大）**

```c
// 直方图均衡化（分步计算，效果更加柔和）
void Transform_color_Histogram_part(IMAGE im)
{
    // 公式：均衡后的颜色值=（最大颜色位255-最小颜色位0）*小于等于该颜色值的像素数量的累加/图片总的像素数

    int Accumulate = 0;             // 保存累加的值
    unsigned char color = 0;                  // 保存颜色的值
    int allBlue[256] = { 0 };       // 保存蓝色直方图
    int allGreen[256] = { 0 };      // 保存绿色直方图
    int allRed[256] = { 0 };        // 保存红色直方图

    // 数组下标等于RBG值极大的简化了计算
    for (unsigned int i = 0; i < im.w * im.h; i++)
    {
        allBlue[im.color[i].blue] += 1;
        allGreen[im.color[i].green] += 1;
        allRed[im.color[i].red] += 1;
    }

    for (unsigned int i = 0; i < im.w * im.h; i++)
    {
        //blue
        for (int j = 0; j <= im.color[i].blue; j++) // 累加计算
            Accumulate += allBlue[j];
        color = (255 - 0) * Accumulate / (im.w * im.h);
        im.color[i].blue = color;
        Accumulate = 0;

        //green
        for (int j = 0; j <= im.color[i].green; j++)// 累加计算
            Accumulate += allGreen[j];
        color = (255 - 0) * Accumulate / (im.w * im.h);
        im.color[i].green = color;
        Accumulate = 0;

        //red
        for (int j = 0; j <= im.color[i].red; j++)// 累加计算
            Accumulate += allRed[j];
        color = (255 - 0) * Accumulate / (im.w * im.h);
        im.color[i].red = color;
        Accumulate = 0;
    }
}

// 直方图均衡化（整体计算，效果更加尖锐）
void Transform_color_Histogram_all(IMAGE im)
{    
    int Accumulate = 0;         // 保存累加的值
    unsigned char color = 0;              // 保存颜色的值
    int allColor[256] = { 0 };  // 保存所有颜色直方图

    // 数组下标等于RBG值极大的简化了计算
    for (unsigned int i = 0; i < im.w * im.h; i++)
    {
        allColor[im.color[i].blue] += 1;
        allColor[im.color[i].green] += 1;
        allColor[im.color[i].red] += 1;
    }

    for (unsigned int i = 0; i < im.w * im.h; i++)
    {
        //blue
        for (int j = 0; j <= im.color[i].blue; j++)// 累加计算
            Accumulate += allColor[j];
        color = (255 - 0) * Accumulate / (im.w * im.h);
        im.color[i].blue = color;
        Accumulate = 0;

        //green
        for (int j = 0; j <= im.color[i].green; j++)// 累加计算
            Accumulate += allColor[j];
        color = (255 - 0) * Accumulate / (im.w * im.h);
        im.color[i].green = color;
        Accumulate = 0;

        //red
        for (int j = 0; j <= im.color[i].red; j++)// 累加计算
            Accumulate += allColor[j];
        color = (255 - 0) * Accumulate / (im.w * im.h);
        im.color[i].red = color;
        Accumulate = 0;
    }
}
```
![请添加图片描述](https://img-blog.csdnimg.cn/6a61d709be8f4610a9af2e69de888d0b.bmp?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aKo5bCYX01P,size_12,color_FFFFFF,t_70,g_se,x_16)
**分步计算，效果更加柔和**
![请添加图片描述](https://img-blog.csdnimg.cn/b2ccc44bb14a4a83837364038cec3c7f.bmp?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aKo5bCYX01P,size_12,color_FFFFFF,t_70,g_se,x_16)
**整体计算，效果更加尖锐**

